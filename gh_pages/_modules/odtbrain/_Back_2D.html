<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odtbrain._Back_2D &mdash; odtbrain 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="odtbrain 0.1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">odtbrain 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for odtbrain._Back_2D</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; 2D reconstruction in optical tomography with the Born approximation</span>

<span class="sd">The first Born approximation for a 2D scattering problem with a plane</span>
<span class="sd">wave </span>
<span class="sd">:math:`u_0(\mathbf{r}) = a_0 \exp(-ik_\mathrm{m}\mathbf{s_0r})`</span>
<span class="sd">reads:</span>

<span class="sd">.. math::</span>
<span class="sd">    u_\mathrm{B}(\mathbf{r}) = \iint \!\! d^2r&#39; </span>
<span class="sd">        G(\mathbf{r-r&#39;}) f(\mathbf{r&#39;}) u_0(\mathbf{r&#39;})</span>

<span class="sd">The Green&#39;s function in 2D is the zero-order Hankel function</span>
<span class="sd">of the first kind:</span>

<span class="sd">.. math::</span>
<span class="sd">    G(\mathbf{r-r&#39;}) = \\frac{i}{4} </span>
<span class="sd">        H_0^\mathrm{(1)}(k_\mathrm{m} \\left| \mathbf{r-r&#39;} \\right|) </span>

<span class="sd">Solving for :math:`f(\mathbf{r})` yields the Fourier diffraction theorem</span>
<span class="sd">in 2D</span>

<span class="sd">.. math::</span>
<span class="sd">    \widehat{F}(k_\mathrm{m}(\mathbf{s-s_0})) = </span>
<span class="sd">        - \sqrt{\\frac{2}{\pi}} </span>
<span class="sd">        \\frac{i k_\mathrm{m}}{a_0} M</span>
<span class="sd">        \widehat{U}_{\mathrm{B},\phi_0}(k_\mathrm{Dx})</span>
<span class="sd">        \exp \! \\left(-i k_\mathrm{m} M l_\mathrm{D} \\right)</span>
<span class="sd">    </span>
<span class="sd">where </span>
<span class="sd">:math:`\widehat{F}(k_\mathrm{x}, k_\mathrm{z})`</span>
<span class="sd">is the Fourier transformed object function and </span>
<span class="sd">:math:`\widehat{U}_{\mathrm{B}, \phi_0}(k_\mathrm{Dx})` is the</span>
<span class="sd">Fourier transformed complex wave that travels along :math:`\mathbf{s_0}`</span>
<span class="sd">(in the direction of :math:`\phi_0`) measured at the detector</span>
<span class="sd">:math:`\mathbf{r_D}`.</span>


<span class="sd">The following identities are used:</span>

<span class="sd">.. math::</span>
<span class="sd">    k_\mathrm{m} (\mathbf{s-s_0}) &amp;= k_\mathrm{Dx} \, \mathbf{t_\perp} +</span>
<span class="sd">    k_\mathrm{m}(M - 1) \, \mathbf{s_0}</span>
<span class="sd">    </span>
<span class="sd">    \mathbf{s_0} &amp;= \\left(p_0 , \, M_0 \\right) = </span>
<span class="sd">    (-\sin\phi_0, \, \cos\phi_0)</span>
<span class="sd">    </span>
<span class="sd">    \mathbf{t_\\perp} &amp;= \\left(- M_0 , \, p_0 \\right) = </span>
<span class="sd">    (\cos\phi_0, \, \sin\phi_0)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="kn">as</span> <span class="nn">intp</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="c">#import warnings</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;backpropagate_2d&quot;</span><span class="p">,</span> <span class="s">&quot;fourier_map_2d&quot;</span><span class="p">,</span> <span class="s">&quot;sum_2d&quot;</span><span class="p">]</span>
<span class="n">_verbose</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="backpropagate_2d"><a class="viewcode-back" href="../../index.html#odtbrain._Back_2D.backpropagate_2d">[docs]</a><span class="k">def</span> <span class="nf">backpropagate_2d</span><span class="p">(</span><span class="n">uSin</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">lD</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">onlyreal</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">padval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">jmc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">jmm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">_verbose</span><span class="p">):</span>
    <span class="sd">u&quot;&quot;&quot; 2D backpropagation with the Fourier diffraction theorem</span>

<span class="sd">    Two-dimensional diffraction tomography reconstruction</span>
<span class="sd">    algorithm for scattering of a plane wave</span>
<span class="sd">    :math:`u_0(\mathbf{r}) = u_0(x,z)` </span>
<span class="sd">    by a dielectric object with refractive index</span>
<span class="sd">    :math:`n(x,z)`.</span>

<span class="sd">    This method implements the backpropagation formula:</span>

<span class="sd">    .. math::</span>
<span class="sd">        f(\mathbf{r}) = </span>
<span class="sd">            - \\frac{i k_\mathrm{m}}{a_0 (2 \pi)^{3/2}}</span>
<span class="sd">            \\int \!\! dk_\mathrm{Dx} \\int_0^{2 \pi} \!\!  d\phi_0 \,</span>
<span class="sd">            \\left| k_\mathrm{Dx} \\right|  </span>
<span class="sd">            \widehat{U}_{\mathrm{B},\phi_0}(k_\mathrm{Dx})</span>
<span class="sd">            \exp( -i k_\mathrm{m} M l_\mathrm{D} )  </span>
<span class="sd">            \exp \! \\left[ i (k_\mathrm{Dx} \, \mathbf{t_\\perp} </span>
<span class="sd">            + k_\mathrm{m}(M - 1) \, \mathbf{s_0})\mathbf{r} \\right] </span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uSin : (A,N) ndarray</span>
<span class="sd">        Two-dimensional sinogram of line recordings</span>
<span class="sd">        :math:`u_{\mathrm{B}, \phi_0}(x_\mathrm{D})`</span>
<span class="sd">        normalized by the amplitude of the unscattered wave :math:`a_0`.</span>
<span class="sd">        measured at the detector.</span>
<span class="sd">    angles : (A,) ndarray</span>
<span class="sd">        Angular positions :math:`\phi_0` of ``uSin`` in radians.</span>
<span class="sd">    res : float</span>
<span class="sd">        Vacuum wavelength of the light :math:`\lambda` in pixels.</span>
<span class="sd">    nm : float</span>
<span class="sd">        Refractive index of the surrounding medium :math:`n_\mathrm{m}`.</span>
<span class="sd">    lD : float</span>
<span class="sd">        Distance from center of rotation to detector plane </span>
<span class="sd">        :math:`l_\mathrm{D}` in pixels.</span>
<span class="sd">    coords : None [(2,M) ndarray], optional</span>
<span class="sd">        Only compute the output image at these coordinates. This</span>
<span class="sd">        keyword is reserved for future versions and is not</span>
<span class="sd">        implemented yet.</span>
<span class="sd">    onlyreal : bool, optional</span>
<span class="sd">        If ``True``, only the real part of the reconstructed image</span>
<span class="sd">        will be returned. This saves computation time.</span>
<span class="sd">    padding : bool, optional</span>
<span class="sd">        Pad the input data to the second next power of 2 before</span>
<span class="sd">        Fourier transforming. This reduces artifacts and speeds up</span>
<span class="sd">        the process for input image sizes that are not powers of 2.</span>
<span class="sd">    padval : float</span>
<span class="sd">        The value used for padding. This is important for the Rytov</span>
<span class="sd">        approximation, where an approximat zero in the phase might</span>
<span class="sd">        translate to 2πi due to the unwrapping algorithm. In that</span>
<span class="sd">        case, this value should be a multiple of 2πi. </span>
<span class="sd">        If `padval` is `None`, then the edge values are used for</span>
<span class="sd">        padding (see documentation of `numpy.pad`).</span>
<span class="sd">    jmc, jmm : instance of :func:`multiprocessing.Value` or `None`</span>
<span class="sd">        The progress of this function can be monitored with the </span>
<span class="sd">        :mod:`jobmanager` package. The current step `jmc.value` is</span>
<span class="sd">        incremented `jmm.value` times. `jmm.value` is set at the </span>
<span class="sd">        beginning.</span>
<span class="sd">    verbose : int</span>
<span class="sd">        Increment to increase verbosity.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : ndarray of shape (N,N), complex if `onlyreal` is False</span>
<span class="sd">        Reconstructed object function :math:`f(\mathbf{r})` as defined</span>
<span class="sd">        by the Helmholtz equation.</span>
<span class="sd">        :math:`f(x,z) = </span>
<span class="sd">        k_m^2 \\left(\\left(\\frac{n(x,z)}{n_m}\\right)^2 -1\\right)`</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    odt_to_ri : conversion of the object function :math:`f(\mathbf{r})` </span>
<span class="sd">        to refractive index :math:`n(\mathbf{r})`.</span>

<span class="sd">    radontea.backproject : backprojection based on the Fourier slice</span>
<span class="sd">        theorem.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">##</span>
    <span class="c">##</span>
    <span class="c"># TODO:</span>
    <span class="c"># - combine the 2nd filter and the rotation in the for loop</span>
    <span class="c"># to save memory. However, memory is not a big issue in 2D.</span>
    <span class="c">##</span>
    <span class="c">##</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">jmm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmm</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="c"># Check input data</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Input data `uB` must have shape (A,N).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="p">)</span> <span class="o">!=</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`len(angles)` must be  equal to `len(uSin)`.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Output coordinates cannot yet&quot;</span> <span class="o">+</span>
                                  <span class="s">&quot; be set for the 2D backrpopagation algorithm.&quot;</span><span class="p">)</span>
    <span class="c"># Cut-Off frequency</span>
    <span class="c"># km [1/px]</span>
    <span class="n">km</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">nm</span><span class="p">)</span> <span class="o">/</span> <span class="n">res</span>
    <span class="c"># The notation in the our optical tomography script for</span>
    <span class="c"># a wave propagating to the right is:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(ikx)</span>
    <span class="c">#</span>
    <span class="c"># However, in physics usually we use the other sign convention:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(-ikx)</span>
    <span class="c">#</span>
    <span class="c"># In order to be consistent with programs like Meep or our</span>
    <span class="c"># scattering script for a dielectric cylinder, we want to use the</span>
    <span class="c"># latter sign convention.</span>
    <span class="c"># This is not a big problem. We only need to multiply the imaginary</span>
    <span class="c"># part of the scattered wave by -1.</span>

    <span class="n">sinogram</span> <span class="o">=</span> <span class="n">uSin</span>

    <span class="c"># Size of the input data</span>
    <span class="n">ln</span> <span class="o">=</span> <span class="n">sinogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># We do a padding before performing the Fourier transform.</span>
    <span class="c"># This gets rid of artifacts due to false periodicity and also</span>
    <span class="c"># speeds up Fourier transforms of the input image size is not</span>
    <span class="c"># a power of 2.</span>
    <span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">64.</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ln</span> <span class="o">*</span> <span class="mf">2.1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">padding</span><span class="p">:</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">order</span> <span class="o">-</span> <span class="n">ln</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">padl</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pad</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">padr</span> <span class="o">=</span> <span class="n">pad</span> <span class="o">-</span> <span class="n">padl</span>

    <span class="k">if</span> <span class="n">padval</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sino</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">padl</span><span class="p">,</span> <span class="n">padr</span><span class="p">)),</span>
                      <span class="n">mode</span><span class="o">=</span><span class="s">&quot;edge&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Padding with edge values.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sino</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">sinogram</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">padl</span><span class="p">,</span> <span class="n">padr</span><span class="p">)),</span>
                      <span class="c"># mode=&quot;constant&quot;, constant_values=((padval,padval),</span>
                      <span class="c">#(padval,padval),(padval,padval)))</span>
                      <span class="n">mode</span><span class="o">=</span><span class="s">&quot;linear_ramp&quot;</span><span class="p">,</span>
                      <span class="n">end_values</span><span class="o">=</span><span class="p">((</span><span class="n">padval</span><span class="p">,</span> <span class="n">padval</span><span class="p">),</span> <span class="p">(</span><span class="n">padval</span><span class="p">,</span> <span class="n">padval</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Verifying padding value: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">padval</span><span class="p">))</span>

    <span class="c"># zero-padded length of sinogram.</span>
    <span class="n">lN</span> <span class="o">=</span> <span class="n">sino</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># Ask for the filter. Do not include zero (first element).</span>
    <span class="c">#</span>
    <span class="c"># Integrals over ϕ₀ [0,2π]; kx [-kₘ,kₘ]</span>
    <span class="c">#   - double coverage factor 1/2 already included</span>
    <span class="c">#   - unitary angular frequency to unitary ordinary frequency</span>
    <span class="c">#     conversion performed in calculation of UB=FT(uB).</span>
    <span class="c">#</span>
    <span class="c"># f(r) = -i kₘ / ((2π)^(3/2) a₀)            (prefactor)</span>
    <span class="c">#      * iint dϕ₀ dkx                       (prefactor)</span>
    <span class="c">#      * |kx|                               (prefactor)</span>
    <span class="c">#      * exp(-i kₘ M lD )                   (prefactor)</span>
    <span class="c">#      * UBϕ₀(kx)                             (dependent on ϕ₀)</span>
    <span class="c">#      * exp( i (kx t⊥ + kₘ (M - 1) s₀) r )   (dependent on ϕ₀ and r)</span>
    <span class="c">#</span>
    <span class="c"># (r and s₀ are vectors. In the last term we perform the dot-product)</span>
    <span class="c">#</span>
    <span class="c"># kₘM = sqrt( kₘ² - kx² )</span>
    <span class="c"># t⊥  = (  cos(ϕ₀), sin(ϕ₀) )</span>
    <span class="c"># s₀  = ( -sin(ϕ₀), cos(ϕ₀) )</span>
    <span class="c">#</span>
    <span class="c"># The filter can be split into two parts</span>
    <span class="c">#</span>
    <span class="c"># 1) part without dependence on the z-coordinate</span>
    <span class="c">#</span>
    <span class="c">#        -i kₘ / ((2π)^(3/2) a₀)</span>
    <span class="c">#      * iint dϕ₀ dkx</span>
    <span class="c">#      * |kx|</span>
    <span class="c">#      * exp(-i kₘ M lD )</span>
    <span class="c">#</span>
    <span class="c"># 2) part with dependence of the z-coordinate</span>
    <span class="c">#</span>
    <span class="c">#        exp( i (kx t⊥ + kₘ (M - 1) s₀) r )</span>
    <span class="c">#</span>
    <span class="c"># The filter (1) can be performed using the classical filter process</span>
    <span class="c"># as in the backprojection algorithm.</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># Corresponding sample frequencies</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">lN</span><span class="p">)</span>  <span class="c"># 1D array</span>
    <span class="c"># kx is a 1D array.</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">fx</span>
    <span class="c"># Differentials for integral</span>
    <span class="n">dphi0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">A</span>
    <span class="c"># We will later multiply with phi0.</span>
    <span class="c">#               a, x</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="n">kx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Low-pass filter:</span>
    <span class="c"># less-than-or-equal would give us zero division error.</span>
    <span class="n">filter_klp</span> <span class="o">=</span> <span class="p">(</span><span class="n">kx</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">km</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># Filter M so there are no nans from the root</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">km</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">km</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_klp</span><span class="p">)</span>

    <span class="c"># We already divided uB by a0 at the very beginning</span>
    <span class="c">#prefactor  = -1j * km / ( 2 * np.pi * a0 )</span>
    <span class="n">prefactor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">dphi0</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_klp</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">lD</span><span class="p">)</span>
    <span class="c"># Perform filtering of the sinogram</span>
    <span class="n">projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">sino</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">prefactor</span>

    <span class="c">#</span>
    <span class="c"># filter (2) must be applied before rotation as well</span>
    <span class="c"># exp( i (kx t⊥ + kₘ (M - 1) s₀) r )</span>
    <span class="c">#</span>
    <span class="c"># t⊥  = (  cos(ϕ₀), sin(ϕ₀) )</span>
    <span class="c"># s₀  = ( -sin(ϕ₀), cos(ϕ₀) )</span>
    <span class="c">#</span>
    <span class="c"># This filter is effectively an inverse Fourier transform</span>
    <span class="c">#</span>
    <span class="c"># exp(i kx xD) exp(i kₘ (M - 1) yD )</span>
    <span class="c">#</span>
    <span class="c"># xD =   x cos(ϕ₀) + y sin(ϕ₀)</span>
    <span class="c"># yD = - x sin(ϕ₀) + y cos(ϕ₀)</span>

    <span class="c"># Everything is in pixels</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">ln</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="c">#x = np.linspace(-center, center, lN, endpoint=False)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lN</span><span class="p">)</span> <span class="o">-</span> <span class="n">center</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span>
    <span class="c"># Meshgrid for output array</span>
    <span class="c">#xv, yv = np.meshgrid(x,x)</span>
    <span class="c">#xv = x.reshape( 1,-1)</span>
    <span class="n">yv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">Mp</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">filter2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">yv</span> <span class="o">*</span> <span class="n">km</span> <span class="o">*</span> <span class="p">(</span><span class="n">Mp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c"># .reshape(1,lN,lN)</span>

    <span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lN</span><span class="p">)</span>  <span class="c"># * filter2</span>

    <span class="c"># Prepare complex output image</span>
    <span class="k">if</span> <span class="n">onlyreal</span><span class="p">:</span>
        <span class="n">outarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ln</span><span class="p">,</span> <span class="n">ln</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ln</span><span class="p">,</span> <span class="n">ln</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">complex</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># Calculate backpropagations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="c"># Create an interpolation object of the projection.</span>

        <span class="c"># if i == A/2:</span>
        <span class="c">#    filter2 = np.conj(filter2)</span>
        <span class="c">#    print(&quot;HA&quot;)</span>

        <span class="c">#xp =  xv*np.cos(phi0) + yv*np.sin(phi0)</span>
        <span class="c">#yp = -xv*np.sin(phi0) + yv*np.cos(phi0)</span>

        <span class="c"># interpolation of the rotated fourier transformed projection</span>
        <span class="c"># this is already tiled onto the entire image.</span>
        <span class="n">sino_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">projection</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">filter2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Resize filtered sinogram back to original size</span>
        <span class="n">sino</span> <span class="o">=</span> <span class="n">sino_filtered</span><span class="p">[:</span><span class="n">ln</span><span class="p">,</span> <span class="n">padl</span><span class="p">:</span><span class="n">padl</span> <span class="o">+</span> <span class="n">ln</span><span class="p">]</span>

        <span class="n">rotated_projr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span>
            <span class="n">sino</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
            <span class="n">reshape</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># Append results</span>

        <span class="n">outarr</span> <span class="o">+=</span> <span class="n">rotated_projr</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">onlyreal</span><span class="p">:</span>
            <span class="n">outarr</span> <span class="o">+=</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span>
                <span class="n">sino</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="o">-</span><span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                <span class="n">reshape</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">outarr</span>

</div>
<div class="viewcode-block" id="fourier_map_2d"><a class="viewcode-back" href="../../index.html#odtbrain._Back_2D.fourier_map_2d">[docs]</a><span class="k">def</span> <span class="nf">fourier_map_2d</span><span class="p">(</span><span class="n">uSin</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">lD</span><span class="p">,</span> <span class="n">semi_coverage</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">coords</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">jmc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">jmm</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">u&quot;&quot;&quot; 2D Fourier mapping with the Fourier diffraction theorem</span>

<span class="sd">    Two-dimensional diffraction tomography reconstruction</span>
<span class="sd">    algorithm for scattering of a plane wave</span>
<span class="sd">    :math:`u_0(\mathbf{r}) = u_0(x,z)` </span>
<span class="sd">    by a dielectric object with refractive index</span>
<span class="sd">    :math:`n(x,z)`.</span>

<span class="sd">    This function implements the solution by interpolation in</span>
<span class="sd">    Fourier space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uSin : (A,N) ndarray</span>
<span class="sd">        Two-dimensional sinogram of line recordings</span>
<span class="sd">        :math:`u_{\mathrm{B}, \phi_0}(x_\mathrm{D})`</span>
<span class="sd">        normalized by the amplitude of the unscattered wave :math:`a_0`.</span>
<span class="sd">        measured at the detector.</span>
<span class="sd">    angles : (A,) ndarray</span>
<span class="sd">        Angular positions :math:`\phi_0` of ``uSin`` in radians.</span>
<span class="sd">    res : float</span>
<span class="sd">        Vacuum wavelength of the light :math:`\lambda` in pixels.</span>
<span class="sd">    nm : float</span>
<span class="sd">        Refractive index of the surrounding medium :math:`n_\mathrm{m}`.</span>
<span class="sd">    lD : float</span>
<span class="sd">        Distance from center of rotation to detector plane </span>
<span class="sd">        :math:`l_\mathrm{D}` in pixels.</span>
<span class="sd">    semi_coverage : bool, optional</span>
<span class="sd">        If set to True, it is assumed that the sinogram does not </span>
<span class="sd">        necessarily cover the full angular range from 0 to 2PI, but an</span>
<span class="sd">        equidistant coverage over 2PI can be achieved by inferring point</span>
<span class="sd">        (anti)symmetry of the (imaginary) real parts of the Fourier </span>
<span class="sd">        transform of f. Valid for any set of angles {X} that result in</span>
<span class="sd">        a 2PI coverage with the union set {X}U{X+PI}.</span>
<span class="sd">    coords : None [(2,M) ndarray], optional</span>
<span class="sd">        Only compute the output image at these coordinates. This</span>
<span class="sd">        keyword is reserved for future versions and is not</span>
<span class="sd">        implemented yet.</span>
<span class="sd">    jmc, jmm : instance of :func:`multiprocessing.Value` or `None`</span>
<span class="sd">        The progress of this function can be monitored with the </span>
<span class="sd">        :mod:`jobmanager` package. The current step `jmc.value` is</span>
<span class="sd">        incremented `jmm.value` times. `jmm.value` is set at the </span>
<span class="sd">        beginning.</span>



<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : ndarray of shape (N,N), complex if `onlyreal` is False</span>
<span class="sd">        Reconstructed object function :math:`f(\mathbf{r})` as defined</span>
<span class="sd">        by the Helmholtz equation.</span>
<span class="sd">        :math:`f(x,z) = </span>
<span class="sd">        k_m^2 \\left(\\left(\\frac{n(x,z)}{n_m}\\right)^2 -1\\right)`</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    backpropagate_2d : implementation by backpropagation</span>
<span class="sd">    odt_to_ri : conversion of the object function :math:`f(\mathbf{r})` </span>
<span class="sd">        to refractive index :math:`n(\mathbf{r})`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">##</span>
    <span class="c">##</span>
    <span class="c"># TODO:</span>
    <span class="c"># - zero-padding as for backpropagate_2D - However this is not</span>
    <span class="c"># necessary as Fourier interpolation is not parallelizable with</span>
    <span class="c"># multiprocessing and thus unattractive. Could be interesting for</span>
    <span class="c"># specific environments without the Python GIL.</span>
    <span class="c"># - Deal with oversampled data. Maybe issue a warning.</span>
    <span class="c">##</span>
    <span class="c">##</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">jmm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmm</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="c"># Check input data</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Input data `uSin` must have shape (A,N).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="p">)</span> <span class="o">!=</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;`len(angles)` must be  equal to `len(uSin)`.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Output coordinates cannot yet&quot;</span> <span class="o">+</span>
                                  <span class="s">&quot; be set for the 2D backrpopagation algorithm.&quot;</span><span class="p">)</span>
    <span class="c"># Cut-Off frequency</span>
    <span class="c"># km [1/px]</span>
    <span class="n">km</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">nm</span><span class="p">)</span> <span class="o">/</span> <span class="n">res</span>

    <span class="c"># Fourier transform of all uB&#39;s</span>
    <span class="c"># In the script we used the unitary angular frequency (uaf) Fourier</span>
    <span class="c"># Transform. The discrete Fourier transform is equivalent to the</span>
    <span class="c"># unitary ordinary frequency (uof) Fourier transform.</span>
    <span class="c">#</span>
    <span class="c"># uof: f₁(ξ) = int f(x) exp(-2πi xξ)</span>
    <span class="c">#</span>
    <span class="c"># uaf: f₃(ω) = (2π)^(-n/2) int f(x) exp(-i ωx)</span>
    <span class="c">#</span>
    <span class="c"># f₁(ω/(2π)) = (2π)^(n/2) f₃(ω)</span>
    <span class="c"># ω = 2πξ</span>
    <span class="c">#</span>
    <span class="c"># Our Backpropagation Formula is with uaf convention of the Form</span>
    <span class="c">#</span>
    <span class="c"># F(k) = 1/sqrt(2π) U(kD)</span>
    <span class="c">#</span>
    <span class="c"># If we convert now to uof convention, we get</span>
    <span class="c">#</span>
    <span class="c"># F(k) = U(kD)</span>
    <span class="c">#</span>
    <span class="c"># This means that if we divide the Fourier transform of the input</span>
    <span class="c"># data by sqrt(2π) to convert f₃(ω) to f₁(ω/(2π)), the resulting</span>
    <span class="c"># value for F is off by a factor of 2π.</span>
    <span class="c">#</span>
    <span class="c"># Instead, we can just multiply *UB* by sqrt(2π) and calculate</span>
    <span class="c"># everything in uof.</span>
    <span class="c">#UB =  np.fft.fft(np.fft.ifftshift(uSin, axes=-1))/np.sqrt(2*np.pi)</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c"># Furthermore, The notation in the our optical tomography script for</span>
    <span class="c"># a wave propagating to the right is:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(ikx)</span>
    <span class="c">#</span>
    <span class="c"># However, in physics usually we use the other sign convention:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(-ikx)</span>
    <span class="c">#</span>
    <span class="c"># In order to be consistent with programs like Meep or our</span>
    <span class="c"># scattering script for a dielectric cylinder, we want to use the</span>
    <span class="c"># latter sign convention.</span>
    <span class="c"># This is not a big problem. We only need to multiply the imaginary</span>
    <span class="c"># part of the scattered wave by -1.</span>

    <span class="c"># The radon transform introduced a shift in the data, which is not</span>
    <span class="c"># conform with the FFT algorithm.</span>
    <span class="n">UB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">uSin</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c"># Corresponding sample frequencies</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c"># 1D array</span>

    <span class="c"># kx is an 1D array.</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">fx</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># Undersampling/oversampling?</span>
    <span class="c"># Determine if the resolution of the image is too low by looking</span>
    <span class="c"># at the maximum value for kx. This is no comparison between</span>
    <span class="c"># Nyquist and Rayleigh frequency.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">km</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
        <span class="c"># Detector is not set up properly. Higher resolution</span>
        <span class="c"># can be achieved.</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Measurement data is undersampled.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Measurement data is oversampled.&quot;</span><span class="p">)</span>
        <span class="c"># raise NotImplementedError(&quot;Oversampled data not yet supported.&quot;+</span>
        <span class="c">#                   &quot; Please rescale xD-axis of the input data.&quot;)</span>
        <span class="c"># DEAL WITH OVERSAMPLED DATA?</span>
        <span class="c">#import IPython</span>
        <span class="c"># IPython.embed()</span>
        <span class="c">#lenk = len(kx)</span>
        <span class="c">#kx = np.fft.ifftshift(np.linspace(-np.sqrt(km),np.sqrt(km),len(fx), endpoint=False))</span>

    <span class="c">#</span>
    <span class="c"># F(kD-kₘs₀) = - i kₘ sqrt(2/π) / a₀ * M exp(-i kₘ M lD) * UB(kD)</span>
    <span class="c"># kₘM = sqrt( kₘ² - kx² )</span>
    <span class="c"># s₀  = ( -sin(ϕ₀), cos(ϕ₀) )</span>
    <span class="c">#</span>
    <span class="c"># We create the 2D interpolation object F</span>
    <span class="c">#   - We compute the real coordinates (krx,kry) = kD-kₘs₀</span>
    <span class="c">#   - We set as grid points the right side of the equation</span>
    <span class="c">#</span>
    <span class="c"># The interpolated griddata may go up to sqrt(2)*kₘ for kx and ky.</span>

    <span class="n">kx</span> <span class="o">=</span> <span class="n">kx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># a0 should have same shape as kx and UB</span>
    <span class="c">#a0 = np.atleast_1d(a0)</span>
    <span class="c">#a0 = a0.reshape(1,-1)</span>

    <span class="n">filter_klp</span> <span class="o">=</span> <span class="p">(</span><span class="n">kx</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">km</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">km</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">km</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c">#Fsin =  -1j * km * np.sqrt(2/np.pi) / a0 * M * np.exp(-1j*km*M*lD)</span>
    <span class="c"># We divided by a0 before.</span>
    <span class="n">Fsin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">lD</span><span class="p">)</span>

    <span class="c"># UB has same shape (len(angles), len(kx))</span>
    <span class="n">Fsin</span> <span class="o">=</span> <span class="n">Fsin</span> <span class="o">*</span> <span class="n">UB</span> <span class="o">*</span> <span class="n">filter_klp</span>

    <span class="n">ang</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">semi_coverage</span><span class="p">:</span>
        <span class="n">Fsin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">Fsin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Fsin</span><span class="p">)))</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ang</span><span class="p">,</span> <span class="n">ang</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># Compute kxl and kyl (in rotated system ϕ₀)</span>
    <span class="n">kxl</span> <span class="o">=</span> <span class="n">kx</span>
    <span class="n">kyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">km</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_klp</span><span class="p">)</span> <span class="o">-</span> <span class="n">km</span>
    <span class="c"># rotate kxl and kyl to where they belong</span>
    <span class="n">krx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">*</span> <span class="n">kxl</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">*</span> <span class="n">kyl</span>
    <span class="n">kry</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">*</span> <span class="n">kxl</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">*</span> <span class="n">kyl</span>

    <span class="n">Xf</span> <span class="o">=</span> <span class="n">krx</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">Yf</span> <span class="o">=</span> <span class="n">kry</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">Zf</span> <span class="o">=</span> <span class="n">Fsin</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c"># DEBUG: plot kry vs krx</span>
    <span class="c">#from matplotlib import pylab as plt</span>
    <span class="c"># plt.figure()</span>
    <span class="c"># for i in range(len(krx)):</span>
    <span class="c">#    plt.plot(krx[i],kry[i],&quot;x&quot;)</span>
    <span class="c"># plt.axes().set_aspect(&#39;equal&#39;)</span>
    <span class="c"># plt.show()</span>

    <span class="c"># Results in the same:</span>
    <span class="c">#Kf = np.zeros((len(Xf),2))</span>
    <span class="c">#Kf[:,0] = Xf</span>
    <span class="c">#Kf[:,1] = Yf</span>
    <span class="c"># Fr=intp.LinearNDInterpolator(Kf,Zf.real)</span>
    <span class="c"># Fi=intp.LinearNDInterpolator(Kf,Zf.imag)</span>
    <span class="c"># How large should the interpolation be?</span>
    <span class="c"># Let&#39;s say</span>
    <span class="c">#Nintp = 512</span>
    <span class="c">#kintp = np.linspace(-km+.5, km-.5, Nintp)</span>
    <span class="c">#Kintx, Kinty = np.meshgrid(kintp,kintp)</span>
    <span class="c">#Kintx = Kintx.flatten()</span>
    <span class="c">#Kinty = Kinty.flatten()</span>
    <span class="c">#coords = np.zeros((len(Kintx), 2))</span>
    <span class="c">#coords[:,0] = Kintx</span>
    <span class="c">#coords[:,1] = Kinty</span>
    <span class="c"># Maybe don&#39;t do everything at once?</span>
    <span class="c">#Fcomp = (Fr(coords) + 1j*Fi(coords)).reshape(Nintp,Nintp)</span>

    <span class="c"># interpolation on grid with same resolution as input data</span>
    <span class="n">kintp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">kx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">Fcomp</span> <span class="o">=</span> <span class="n">intp</span><span class="o">.</span><span class="n">griddata</span><span class="p">((</span><span class="n">Xf</span><span class="p">,</span> <span class="n">Yf</span><span class="p">),</span> <span class="n">Zf</span><span class="p">,</span> <span class="p">(</span><span class="n">kintp</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">kintp</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># removed nans</span>
    <span class="n">Fcomp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Fcomp</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Filter data</span>
    <span class="n">kinx</span><span class="p">,</span> <span class="n">kiny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">kx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">kx</span><span class="p">))</span>
    <span class="n">Fcomp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">kinx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">kiny</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">km</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># DEBUG: Output filtered fourier image</span>
    <span class="c">#proc_arr2im(Fcomp, scale=True).save(&quot;Fourier.bmp&quot;)</span>

    <span class="c">#Fcomp[np.where(kinx**2+kiny**2&lt;km)] = 0</span>

    <span class="c"># Fcomp is centered at K = 0 due to the way we chose kintp/coords</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">Fcomp</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="sum_2d"><a class="viewcode-back" href="../../index.html#odtbrain._Back_2D.sum_2d">[docs]</a><span class="k">def</span> <span class="nf">sum_2d</span><span class="p">(</span><span class="n">uSin</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">lD</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">jmc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">jmm</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">u&quot;&quot;&quot; 2D sum-reconstruction with the Fourier diffraction theorem</span>

<span class="sd">    Two-dimensional diffraction tomography reconstruction</span>
<span class="sd">    algorithm for scattering of a plane wave</span>
<span class="sd">    :math:`u_0(\mathbf{r}) = u_0(x,z)` </span>
<span class="sd">    by a dielectric object with refractive index</span>
<span class="sd">    :math:`n(x,z)`.</span>

<span class="sd">    This function implements the solution by summation in real</span>
<span class="sd">    space, which is extremely slow.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uSin : (A,N) ndarray</span>
<span class="sd">        Two-dimensional sinogram of line recordings</span>
<span class="sd">        :math:`u_{\mathrm{B}, \phi_0}(x_\mathrm{D})`</span>
<span class="sd">        normalized by the amplitude of the unscattered wave :math:`a_0`.</span>
<span class="sd">        measured at the detector.</span>
<span class="sd">    angles : (A,) ndarray</span>
<span class="sd">        Angular positions :math:`\phi_0` of ``uSin`` in radians.</span>
<span class="sd">    res : float</span>
<span class="sd">        Vacuum wavelength of the light :math:`\lambda` in pixels.</span>
<span class="sd">    nm : float</span>
<span class="sd">        Refractive index of the surrounding medium :math:`n_\mathrm{m}`.</span>
<span class="sd">    lD : float</span>
<span class="sd">        Distance from center of rotation to detector plane </span>
<span class="sd">        :math:`l_\mathrm{D}` in pixels.</span>
<span class="sd">    coords : None or (2,M) ndarray], optional</span>
<span class="sd">        Only compute the output image at these coordinates. This</span>
<span class="sd">        keyword is reserved for future versions and is not</span>
<span class="sd">        implemented yet.</span>
<span class="sd">    jmc, jmm : instance of :func:`multiprocessing.Value` or `None`</span>
<span class="sd">        The progress of this function can be monitored with the </span>
<span class="sd">        :mod:`jobmanager` package. The current step `jmc.value` is</span>
<span class="sd">        incremented `jmm.value` times. `jmm.value` is set at the </span>
<span class="sd">        beginning.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : ndarray of shape (N,N), complex if `onlyreal` is False</span>
<span class="sd">        Reconstructed object function :math:`f(\mathbf{r})` as defined</span>
<span class="sd">        by the Helmholtz equation.</span>
<span class="sd">        :math:`f(x,z) = </span>
<span class="sd">        k_m^2 \\left(\\left(\\frac{n(x,z)}{n_m}\\right)^2 -1\\right)`</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    backpropagate_2d : implementation by backprojection</span>
<span class="sd">    fourier_map_2d : implementation by Fourier interpolation</span>
<span class="sd">    odt_to_ri : conversion of the object function :math:`f(\mathbf{r})` </span>
<span class="sd">        to refractive index :math:`n(\mathbf{r})`.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method is not meant for production use. The computation time</span>
<span class="sd">    is very long and the reconstruction quality is bad. This function</span>
<span class="sd">    is included in the package, because of its educational value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">lx</span> <span class="o">=</span> <span class="n">uSin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">lx</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">lx</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">lx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">lx</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">xv</span><span class="o">.</span><span class="n">flat</span>
        <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">yv</span><span class="o">.</span><span class="n">flat</span>
    
    
    <span class="k">if</span> <span class="n">jmm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmm</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c"># Cut-Off frequency</span>
    <span class="n">km</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">nm</span><span class="p">)</span> <span class="o">/</span> <span class="n">res</span>

    <span class="c"># Fourier transform of all uB&#39;s</span>
    <span class="c"># In the script we used the unitary angular frequency (uaf) Fourier</span>
    <span class="c"># Transform. The discrete Fourier transform is equivalent to the</span>
    <span class="c"># unitary ordinary frequency (uof) Fourier transform.</span>
    <span class="c">#</span>
    <span class="c"># uof: f₁(ξ) = int f(x) exp(-2πi xξ)</span>
    <span class="c">#</span>
    <span class="c"># uaf: f₃(ω) = (2π)^(-n/2) int f(x) exp(-i ωx)</span>
    <span class="c">#</span>
    <span class="c"># f₁(ω/(2π)) = (2π)^(n/2) f₃(ω)</span>
    <span class="c"># ω = 2πξ</span>
    <span class="c">#</span>
    <span class="c"># We have a one-dimensional (n=1) Fourier transform and UB in the</span>
    <span class="c"># script is equivalent to f₃(ω). Because we are working with the</span>
    <span class="c"># uaf, we divide by sqrt(2π) after computing the fft with the uof.</span>
    <span class="c">#</span>
    <span class="c"># We calculate the fourier transform of uB further below. This is</span>
    <span class="c"># necessary for memory control.</span>

    <span class="c"># Corresponding sample frequencies</span>
    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">uSin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># 1D array</span>
    <span class="c"># kx is a 1D array.</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">fx</span>

    <span class="c"># Undersampling/oversampling?</span>
    <span class="c"># Determine if the resolution of the image is too low by looking</span>
    <span class="c"># at the maximum value for kx. This is no comparison between</span>
    <span class="c"># Nyquist and Rayleigh frequency.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">km</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
        <span class="c"># Detector is not set up properly. Higher resolution</span>
        <span class="c"># can be achieved.</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Measurement data is undersampled.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;......Measurement data is oversampled.&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Oversampled data not yet supported.&quot;</span> <span class="o">+</span>
                                  <span class="s">&quot; Please rescale input data&quot;</span><span class="p">)</span>

    <span class="c"># Differentials for integral</span>
    <span class="n">dphi0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">dkx</span> <span class="o">=</span> <span class="n">kx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># We will later multiply with phi0.</span>
    <span class="c"># Make sure we are using correct shapes</span>
    <span class="c">#kx=kx.reshape(1, kx.shape[0], kx.shape[1])</span>
    <span class="c">#ky=ky.reshape(1, ky.shape[0], ky.shape[1])</span>
    <span class="n">kx</span> <span class="o">=</span> <span class="n">kx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c"># Low-pass filter:</span>
    <span class="c"># less-than-or-equal would give us zero division error.</span>
    <span class="n">filter_klp</span> <span class="o">=</span> <span class="p">(</span><span class="n">kx</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">km</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># a0 will be multiplied with kx</span>
    <span class="c">#a0 = np.atleast_1d(a0)</span>
    <span class="c">#a0 = a0.reshape(1,-1)</span>

    <span class="c"># Create the integrand</span>
    <span class="c"># Integrals over ϕ₀ [0,2π]; kx [-kₘ,kₘ]</span>
    <span class="c">#   - double coverage factor 1/2 already included</span>
    <span class="c">#   - unitary angular frequency to unitary ordinary frequency</span>
    <span class="c">#     conversion performed in calculation of UB=FT(uB).</span>
    <span class="c">#</span>
    <span class="c"># f(r) = -i kₘ / ((2π)^(3/2) a₀)            (prefactor)</span>
    <span class="c">#      * iint dϕ₀ dkx                       (prefactor)</span>
    <span class="c">#      * |kx|                               (prefactor)</span>
    <span class="c">#      * exp(-i kₘ M lD )                   (prefactor)</span>
    <span class="c">#      * UBϕ₀(kx)                             (dependent on ϕ₀)</span>
    <span class="c">#      * exp( i (kx t⊥ + kₘ (M - 1) s₀) r )   (dependent on ϕ₀ and r)</span>
    <span class="c">#</span>
    <span class="c"># (r and s₀ are vectors. In the last term we perform the dot-product)</span>
    <span class="c">#</span>
    <span class="c"># kₘM = sqrt( kₘ² - kx² )</span>
    <span class="c"># t⊥  = (  cos(ϕ₀), sin(ϕ₀) )</span>
    <span class="c"># s₀  = ( -sin(ϕ₀), cos(ϕ₀) )</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c"># everything that is not dependent on phi0:</span>
    <span class="c">#</span>
    <span class="c"># Filter M so there are no nans from the root</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">km</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">km</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_klp</span><span class="p">)</span>
    <span class="n">prefactor</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">3.</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">dphi0</span> <span class="o">*</span> <span class="n">dkx</span>
    <span class="c"># Also filter the prefactor, so nothing outside the required</span>
    <span class="c"># low-pass contributes to the sum.</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kx</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_klp</span>
    <span class="n">prefactor</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="n">km</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">lD</span><span class="p">)</span>

    <span class="c"># Initiate function f</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="n">lenf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">lenu0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uSin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c"># lenu0 = len(kx[0])</span>

    <span class="c"># Initiate vector r that corresponds to calculating a value of f.</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c"># Everything is normal.</span>
    <span class="c"># Get the angles ϕ₀.</span>
    <span class="n">phi0</span> <span class="o">=</span> <span class="n">angles</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Compute the Fourier transform of uB.</span>
    <span class="c"># This is true: np.fft.fft(UB)[0] == np.fft.fft(UB[0])</span>
    <span class="c"># because axis -1 is always used.</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c"># Furthermore, The notation in the our optical tomography script for</span>
    <span class="c"># a wave propagating to the right is:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(ikx)</span>
    <span class="c">#</span>
    <span class="c"># However, in physics usually usethe other sign convention:</span>
    <span class="c">#</span>
    <span class="c">#    u0(x) = exp(-ikx)</span>
    <span class="c">#</span>
    <span class="c"># In order to be consisten with programs like Meep or our scattering</span>
    <span class="c"># script for a dielectric cylinder, we want to use the latter sign</span>
    <span class="c"># convention.</span>
    <span class="c"># This is not a big problem. We only need to multiply the imaginary</span>
    <span class="c"># part of the scattered wave by -1.</span>
    <span class="n">UB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">uSin</span><span class="p">,</span> <span class="n">axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">UBi</span> <span class="o">=</span> <span class="n">UB</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">lenu0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">lenf</span><span class="p">):</span>
        <span class="c"># Get r (We compute f(r) in this for-loop)</span>
        <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c"># x</span>
        <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>  <span class="c"># y</span>

        <span class="c"># Integrand changes with r, so we have to create a new</span>
        <span class="c"># array:</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">prefactor</span> <span class="o">*</span> <span class="n">UBi</span>

        <span class="c"># We save memory by directly applying the following to</span>
        <span class="c"># the integrand:</span>
        <span class="c">#</span>
        <span class="c"># Vector along which we measured</span>
        <span class="c">#s0 = np.zeros((2, phi0.shape[0], kx.shape[0]))</span>
        <span class="c">#s0[0] = -np.sin(phi0)</span>
        <span class="c">#s0[1] = +np.cos(phi0)</span>

        <span class="c"># Vector perpendicular to s0</span>
        <span class="c">#t_perp_kx = np.zeros((2, phi0.shape[0], kx.shape[1]))</span>
        <span class="c">#</span>
        <span class="c">#t_perp_kx[0] = kx*np.cos(phi0)</span>
        <span class="c">#t_perp_kx[1] = kx*np.sin(phi0)</span>

        <span class="c">#</span>
        <span class="c">#term3 = np.exp(1j*np.sum(r*( t_perp_kx + (gamma-km)*s0 ), axis=0))</span>
        <span class="c"># integrand* = term3</span>
        <span class="c">#</span>
        <span class="c"># Reminder:</span>
        <span class="c"># f(r) = -i kₘ / ((2π)^(3/2) a₀)            (prefactor)</span>
        <span class="c">#      * iint dϕ₀ dkx                       (prefactor)</span>
        <span class="c">#      * |kx|                               (prefactor)</span>
        <span class="c">#      * exp(-i kₘ M lD )                   (prefactor)</span>
        <span class="c">#      * UB(kx)                             (dependent on ϕ₀)</span>
        <span class="c">#      * exp( i (kx t⊥ + kₘ(M - 1) s₀) r )   (dependent on ϕ₀ and r)</span>
        <span class="c">#</span>
        <span class="c"># (r and s₀ are vectors. In the last term we perform the dot-product)</span>
        <span class="c">#</span>
        <span class="c"># kₘM = sqrt( kₘ² - kx² )</span>
        <span class="c"># t⊥  = (  cos(ϕ₀), sin(ϕ₀) )</span>
        <span class="c"># s₀  = ( -sin(ϕ₀), cos(ϕ₀) )</span>
        <span class="n">integrand</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1j</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">kx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi0</span><span class="p">)</span> <span class="o">-</span> <span class="n">km</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi0</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">kx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi0</span><span class="p">)</span> <span class="o">+</span> <span class="n">km</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi0</span><span class="p">))))</span>

        <span class="c"># Calculate the integral for the position r</span>
        <span class="c"># integrand.sort()</span>
        <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">integrand</span><span class="p">)</span>

        <span class="c"># free memory</span>
        <span class="k">del</span> <span class="n">integrand</span>

        <span class="k">if</span> <span class="n">jmc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">jmc</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">odtbrain 0.1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Paul Müller.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>